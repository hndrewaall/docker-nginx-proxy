# Generated nginx site conf
{{/* MAPPING of configuration env vars to file globals avoiding problems within nested env access. */}}

{{/* Default vals where necessary */}}
{{ $infix := "" }}
{{ $bundleEnabled := "0" }}
{{ $autoRedirectEnabled := "0" }}
{{ $prefix := "" }}
{{ $spdyEnabled := "0" }}

{{/* Global env var assignments */}}
{{ $infix := .Env.GLOB_SSL_CERT_BUNDLE_INFIX }}
{{ $autoRedirectEnabled := .Env.GLOB_AUTO_REDIRECT_ENABLED }}
{{ $prefix := .Env.GLOB_AUTO_REDIRECT_PREFIX }}

{{ $spdyEnabled := .Env.GLOB_SPDY_ENABLED }}

{{ $unavailableService := .Env.GLOB_HTTP_NO_SERVICE }}
{{ $autoRedirectDirection := .Env.GLOB_AUTO_REDIRECT_DIRECTION }}
{{ $sslSessionTimeout := .Env.GLOB_SSL_SESSION_TIMEOUT }}
{{ $sslSessionCache := .Env.GLOB_SSL_SESSION_CACHE }}

## configuration input check
# bundled: {{.Env.GLOB_SSL_CERT_BUNDLE_ENABLED}}
# bundled infix: {{.Env.GLOB_SSL_CERT_BUNDLE_INFIX}}
# auto redirect: {{.Env.GLOB_AUTO_REDIRECT_WITH_PREFIX_ENABLED}}
# redirect prefix: {{.Env.GLOB_AUTO_REDIRECT_PREFIX}}
# redirect direction: {{.Env.GLOB_AUTO_REDIRECT_DIRECTION}}

# spdy enabled: {{.Env.GLOB_SPDY_ENABLED}}
# unavailable service code: {{.Env.GLOB_HTTP_NO_SERVICE}}
# ssl session timeout: {{.Env.GLOB_SSL_SESSION_TIMEOUT}}
# ssl session cache size: {{.Env.GLOB_SSL_SESSION_CACHE}}


## configuration data
# bundled: {{$bundleEnabled}}
# bundled infix: {{$infix}}
# auto redirect: {{$autoRedirectEnabled}}
# redirect prefix: {{$prefix}}
# redirect direction: {{$autoRedirectDirection}}

# unavailable service code: {{$unavailableService}}
# ssl session timeout: {{$sslSessionTimeout}}
# ssl session cache size: {{$sslSessionCache}}

# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
# scheme used to connect to this server
map $http_x_forwarded_proto $proxy_x_forwarded_proto {
  default $http_x_forwarded_proto;
  ''      $scheme;
}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
map $http_upgrade $proxy_connection {
  default upgrade;
  ''      '';
}

gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

log_format vhost '$host $remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent '
                 '"$http_referer" "$http_user_agent"';

access_log /proc/self/fd/1 vhost;
error_log /proc/self/fd/2;

client_max_body_size {{ .Env.GLOB_MAX_BODY_SIZE }};

# HTTP 1.1 support
proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $proxy_connection;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;

# Catching any if there is no real hostname
server {
        listen 80 default_server;
        server_name _;
        return {{ $unavailableService }};
}

{{/* MAIN VIRTUAL_HOST generation. */}}
{{ range $hostAndPort, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
{{ $host := first ( split $hostAndPort ":" ) }}
{{ $port := last ( split $hostAndPort ":" ) }}

upstream {{ $host }} {

{{/* UPSTREAM GENERATION. */}}
{{ range $container := $containers }}

	{{ $addrLen := len $container.Addresses }}
    
    {{/* ADDRESSING SWITCH CASE. */}}
    
	{{ if eq $addrLen 1 }}
	{{/* Address/Port count == 1, use the only one */}}
    
		{{ with $address := index $container.Addresses 0 }}
        # {{$container.Name}}.single 
        server {{ $address.IP }}:{{ $address.Port }};
		{{ end }}
        
    {{ else if (and ($port) (ne $host $port)) }}
    {{/* Address/Port count != 1, target port via ':' seperator provided */}}
    
    	{{ range $address := .Addresses }}
    
    	   {{ if eq $address.Port $port }}
        # {{$container.Name}}.explicit
        server {{ $address.IP }}:{{ $address.Port }};
    	   {{ end }}
       
    	{{ end }}
    
	{{ else if $container.Env.VIRTUAL_PORT }}
    {{/* Port count != 1, VIRTUAL_PORT found, use given */}}
    
		{{ range $address := .Addresses }}
        
		   {{ if eq $address.Port $container.Env.VIRTUAL_PORT }}
        # {{$container.Name}}.explicit
        server {{ $address.IP }}:{{ $address.Port }};
		   {{ end }}
           
		{{ end }}
	
	{{ else }}
    {{/* Try to default to standard web port 80  */}}
    	
    	{{ range $address := $container.Addresses }}

            {{ if eq $address.Port "80" }}
            
        # {{$container.Name}}.default
        server {{ $address.IP }}:{{ $address.Port }};

            {{ end }}

        {{/* $container.Addresses end */}}
		{{ end }}

    {{/* ADRESSING SWITCH. end */}}
	{{ end }}
    
{{/* UPSTREAM GENERATION. end */}}
{{ end }}
}

{{/* Get the VIRTUAL_PROTO defined by containers w/ the same vhost, falling back to "http" */}}
{{ $proto := or (first (groupByKeys $containers "Env.VIRTUAL_PROTO")) "http" }}

{{/* Get the first cert name defined by containers w/ the same vhost */}}
{{ $certName := (first (groupByKeys $containers "Env.CERT_NAME")) }}

{{/* Get the best matching cert  by name for the vhost. */}}
{{ $vhostCert := (closest (dir "/etc/nginx/certs") (printf "%s.crt" $host))}}

{{/* vhostCert is actually a filename so remove any suffixes since they are added later */}}
{{ $vhostCert := replace $vhostCert ".crt" "" -1 }}
{{ $vhostCert := replace $vhostCert ".key" "" -1 }}

{{/* Use the cert specifid on the container or fallback to the best vhost match */}}
{{ $cert := (coalesce $certName $vhostCert) }}

{{/* MAIN server configuration task. */}}
{{ if (and (ne $cert "") (exists (printf "/etc/nginx/certs/%s.crt" $cert)) (exists (printf "/etc/nginx/certs/%s.key" $cert))) }}
{{/* Valid HTTPS certificate and key files found. */}}

{{ if eq $autoRedirectEnabled "1" }}

server {

    {{ if eq $autoRedirectDirection "0" }}
    {{/* Redirect prefixed host to plain host via moved permanently */}}
    
        server_name  {{ $prefix }}.{{ $host }};
        listen 443 ssl;
        rewrite ^(.*) https://{{ $host }}$1 permanent;
    
    {{ else }}
    {{/* Redirect non-prefixed host to prefixed host via moved permanently */}}
    
        server_name {{ $host }};
        listen 443 ssl;
        rewrite ^(.*) https://{{ $prefix }}.{{ $host }}$1 permanent;
    
    {{/* AUTO_REDIRECT_DIRECTION end */}}
    {{ end }}

}

{{/* AUTO_REDIRECT_WITH_PREFIX_ENABLED end */}}
{{ end }}

{{/* Enforce https, redirect http */}}
server {
        server_name {{ $host }};
        rewrite ^(.*) https://{{ $host }}$1 permanent;
}

{{/* SSL handling server */}}
server {
        server_name {{ $host }};
    
    {{/* SPDY effect 1 */}}
    {{ if eq $spdyEnabled "1" }}
        listen 443 ssl spdy;
    {{ else }}
        listen 443 ssl;
    {{ end }}
    
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA;

        ssl_prefer_server_ciphers on;
        ssl_session_timeout {{ $sslSessionTimeout }};
        ssl_session_cache shared:SSL:{{ $sslSessionCache }};

        {{ $certBundle := replace "ccii" "cc" $cert -1 }}
        {{ $certBundle := replace $certBundle "ii" $infix -1 }}

        ssl_certificate /etc/nginx/certs/{{ (printf "%s.crt" $certBundle) }};
        ssl_certificate_key /etc/nginx/certs/{{ (printf "%s.key" $cert) }};

        {{/* SPDY effect 2 */}}
        {{ if eq $spdyEnabled 1 }}
        add_header Alternate-Protocol  443:npn-spdy/3;
        {{ end }}
        
        add_header Strict-Transport-Security "max-age=31536000; includeSubdomains";

        {{/* Custom include handling */}}
        {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
        include {{ printf "/etc/nginx/vhost.d/%s" $host }};
        {{ end }}

        location / {
            
            {{/* Pass with proto optionally to provide forcing connection to backend via protocol like HTTPS if necessary */}}
            proxy_pass {{ $proto }}://{{ $host }};
            
            {{/* Add basic auth if htpasswd dir contains a file named like the host */}}
            {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
            auth_basic "Provide authentication for {{ $host }}";
            auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
            {{ end }}
        }
}

{{/* Valid HTTPS certificate and key files found. end */}}
{{ else }} 
{{/* Defaulting to HTTP. */}}

{{ if eq $autoRedirectEnabled "1" }}

server {
    {{ if eq $autoRedirectDirection "0" }}
    
        server_name  {{ $prefix }}.{{ $host }};
        rewrite ^(.*) http://{{ $host }}$1 permanent;
   
    {{ else }}
    
        server_name {{ $host }};
        rewrite ^(.*) http://{{ $prefix }}.{{ $host }}$1 permanent;
    
    {{ end }}
}

{{/* AUTO_REDIRECT_WITH_PREFIX_ENABLED end. */}}
{{ end }}

{{/* HTTP proxy */}}
server {
        server_name {{ $host }};

        {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
        include {{ printf "/etc/nginx/vhost.d/%s" $host }};
        {{ end }}

        location / {
                proxy_pass {{ $proto }}://{{ $host }};
                
                {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
                auth_basic "Provide authentication for {{ $host }}";
                auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
                {{ end }}
        }
}

{{ if (and (exists "/etc/nginx/certs/default.crt") (exists "/etc/nginx/certs/default.key")) }}
server {
        server_name {{ $host }};
        listen 443 ssl;
        return {{ $unavailableService }};

        ssl_certificate /etc/nginx/certs/default.crt;
        ssl_certificate_key /etc/nginx/certs/default.key;
}
{{ end }}

{{/* MAIN server configuration task. end */}}
{{ end }}

{{/* MAIN VIRTUAL_HOST generation. end */}}
{{ end }}
